---
layout: post
title:  tcp udp learn
date: 2020-02-23
tag: network
---
<br>

## 传输层 TCP UDP学习  

将之前在幕布整理的tcp udp知识点再学习加深下   
tcp udp位于网络通信协议的第四层 - 传输层  
保证层尽量传输数据的可靠性  
数据链路层通过MAC识别，网络层通过IP识别，传输层通过端口识别  

### TCP - Transmission Control Protocol  

* 报文头  
> 1. 目的端口号   
> 2. 源端口号  
> 3. 序列号 - seq - 发送数据相对位置，每发送一次数据，就累加该数据字节数大小置为序列号  
> 4. 确认应答号 - ack - 告诉发送端下一次应该收到的数据的序列号，一般为收到的序列号+1，表示正常接收到你发过来的seq为ack-1的数据，需要你发送之后的数据  
> 5. 控制位 - 8个标识位
> > ACK - 1，确认应答的字段有效  
> > SYN - 1，希望建立连接标识  
> > FIN - 1，表示今后不会再有数据发送，但是还可以接收数据，希望断开连接标识   

> 6. 窗口大小 - 滑动窗口大小  
> 7. 校验和 - 校验TCP首部数据传输的正确性  
> 8. 选项 - Mss - tcp最大段长度  

* 特点  
> 面向连接的可靠性传输
> 提供纠错，重发，拥塞控制，顺序控制  
> 需要可靠消息的场景

* 上层应用协议  
> http/https ftp pop3  

* 三次建立连接  
![tcp_hand](/images/posts/tcp_udp/tcp_hand.svg)  

* 四次断开连接   
![tcp_unhand](/images/posts/tcp_udp/tcp_unhand.svg)  

* 高可靠性  
> SEQ-ACK - 序列号和确认应答号保证了消息的接收和失败重传  
> 一般ACK号为接收的SEQ号+1，表示已经正确的接收到上一次S数据段，期望传输下一数据段
> 超时重传 - 超过特定时间还没有收到发送的seq号标记数据段应该返回的ack确认应答，发送方就会对那个数据段重新传输  

* 高吞吐  
> 分段传输
> > 由于IP协议分片， tcp段长度 + ip头 <= ip分片长度mtu  
> > mtu - 网络能支持的ip最大分片长度，不同环境支持的mtu大小不同  
> > 通过icmp协议确定网络最小mtu  
> > tcp最大分段长度mss应小于mtu  
> > tcp建立连接时，通过syn包互相通知mss值，两者取较小值为统一mss  

> 滑动窗口  
> > 分段传输如果对每个数据段都应答ack会降低性能  
> > 所以确认应答ack不以段为单位，而已窗口大小为单位进行应答  
> > 滑动窗口减少了应答次数从而提高了传输性能  
> > 设置窗口的大小进而进行流控制  
> > 拥塞控制 - 满启动算法调整窗口大小，避免通信开始时流量过大导致拥塞
> > 但就是由于刚建立连接时的满启动算法设置的窗口太小，导致tcp连接建立性能不佳  


### UDP - User Datagram Protocol  

* 报文头  
> 1. 目的端口号   
> 2. 源端口号  
> 3. 校验和 - 校验UDP首部数据传输正确性  
> 4. 包长度 - UDP首部与数据部分之和  

* 特点  
> 无连接，不纠错，不重发，没有拥塞控制  
> 可以通过包长度字段保证消息大小  
> 用于数据可靠性要求不高的音视频场景，广播通讯场景  
> 上层应用协议 dns snmp ntp  

<br>  

### wireshark   

* 过滤  

```
(ip.dst == 192.167.2.1 || ip.src == 192.167.2.1) and tcp.port == 4563 and tcp  
```

相关好文:  
[tcp之recv/send和滑动窗口知识学习](https://www.cnblogs.com/lisuyun/articles/5803352.html)  

<br>
<br>

*转载请注明* [from tomsun28](http://usthe.com)
