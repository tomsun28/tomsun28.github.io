---
layout: post
title: java virtual machine_learn
date: 2017-10-27
tag: java
---

# Java虚拟机学习

<br>

## JVM

<br>
  JVM是一个虚构出来的计算机,有自己的处理器,堆栈,寄存器以及相应的指令系统等。JVM是JRE的一部分,通过在实际的计算机上仿真模拟各种计算机功能,这样就能使Java在跨平台上运行。

<br>
<br>

## JVM内存区域划分

<br>

![](/images/posts/jvm/image1.png)

<br>
JVM的内部体系结构分为三个部分,分别为类装载器子系统,运行时数据区和执行引擎。

<br>
<br>
### 类装载器子系统(ClassLoader)

<br>
  每个Java虚拟机都有一个类加载器,负责查找并加载程序中的类,接口,并给其确定唯一的名字。Java虚拟机有两种类装载器：系统类装载器和用户自定义类装载器,系统类装载器是JVM实现的一部分,用户自定义类装载器是Java程序的一部分,其必须是类装载器ClassLoader类的子类。
<br>

![](/images/posts/jvm/image2.png)

<br>

* 启动类装载器(bootstrap calss loader): 其用来加载Java的核心库,用原生代码来实现的,没有继承java.lang.ClassLoader 
* 扩展类装载器(extensions class loader): 其用来加载Java的扩展库,Jav虚拟机的实现会提供一个扩展库目录,该装载器就是在这个目录下查找加载类。
* 应用程序类装载器(application class loader): 其根据java应用的类路径(classpath)来加载Java应用的类。通过ClassLoader.getSystemClassLoader()获取它。
* 用户自定义装载器(user class loader): 除了系统提供的类装载器之外,我们还可以通过继承java.lang.ClassLoader类的方式来实现自己的类装载器来满足一些特殊的需求。

<br>
  类装载器子系统涉及Java虚拟机的其它组成部分和来自java.lang库的类。ClassLoader类定义的方法为程序提供了访问类装载器机制的接口。对于每个被装载的类型,Java虚拟机都会给它创建一个java.lang.Class类的实例来代表该类型。和其它对象一样,用户自定义的类装载器以及Class类的实例放在内存的堆区,装载的类型信息位于方法区。
<br>
  类装载器子系统除了要查找定位导入二进制class文件外,还需要负责验证被导入的类的正确性,为类的类变量分配并初始化内存,以及解析符号引用。顺序是: 
  装载(查找并装载类型的二进制数据)——>连接(验证确保被导入类型的正确性,为类变量分配内存,并将其初始化为默认值,把类型中的符号引用转换为直接引用)——>初始化(将类变量初始化为正确的初始值)
- - -
<br>
<br>

### 执行引擎：执行字节码或者执行调用的本地方法----执行引擎的行为由指令集定义

<br>
  指令集：Java方法的字节码流由Java虚拟机的指令序列构成。每条指令包含：一个单字节的操作码(表示需要执行的操作),0或多个操作数(操作数向Java虚拟机提供执行操作码的额外信息,使指令使用的值可能来自当前常量池中的项,当前帧的局部变量中的值或者当前操作数栈顶端的值)。
<br>
  运行中的Java程序的每一个线程都是一个独立的虚拟机执行引擎的实例。从线程生命周期的开始到结束,它要么在执行字节码,要么在执行本地方法。
<br>
  主要的执行技术有：解释,及时编译,自适应优化,芯片级直接执行。自适应优化吸取解释和及时编译的优点,采取两种结合的方式。
  自适应优化——开始对所有的代码都采取解释执行的方式并监视代码的执行情况,然后对那些经常调用的方法启动一个后台线程,将其及时编译为本地代码进行调用,并进行仔细优化。当该方法不再频繁的被调用,则取消编译过的代码,将其归为解释执行。
- - -
<br>
<br>

### 运行时数据区：方法区,堆,Java栈,PC寄存器,本地方法栈

<br>
![](/images/posts/jvm/image3.png)
<br>

* #### 方法区——线程共享

<br>
>  当虚拟机装载某个类型时,它使用类装载器定位载入相应的.class文件到虚拟机中,接着虚拟机提取其中的类型信息,并将这些信息存储到方法区。当开发人员在程序中通过Class对象的getName(),isInterface()等方法来获取信息时,这些数据都会来源于方法区,同时方法区也是全局共享的,在一定条件下它也会被GC掉(虚拟机允许通过用户自定义的类装载器来动态扩展Java程序,此时方法区也可以被垃圾回收器收集),当方法区需要使用的内存超过最大允许时,会抛出OutOfMemory。
>
>  方法区存放内容如下：
>  * 已经被虚拟机所加载的类信息(类名称,类类型(接口还是类),修饰符,类的直接超类名称),
>  * 类中的静态(类)变量,
>  * 运行常量池runtime constant pool (类中定义的final类型的常量,一个有序集合,包括直接常量(string,integer,floating 常量)和对其他类型,字段,方法的符号引用)——class文件除了有类信息外,还有一项是常量池(constant pool table),常量池用于存放编译期生成的各种字面量和符号的引用,这部分内容将在类加载后进入方法区的运行时常量池中存储。——运行时常量池相对于class文件常量池的一个重要特征是具备动态性：即除了可以存储class文件常量池中的内容外,运行期间也可能将新的常量放入到池中,比如String类的intern()方法,
>  * 类中的方法信息(方法名,返回类型,参数数量和类型,修饰符),
>  * 字段信息(字段名,类型,修饰符),
>  * 指向ClassLoader类的引用(每个类型被装载时,虚拟机必须跟踪确定它是由系统类装载器还是由用户自定义装载器装载的),
>  * 指向Class类的引用(对于每隔一个被装载的类型,虚拟机都为其相应的创建了一个java.lang.Class类实例)
>    - - -

<br>
<br>

* #### 堆(heap)——线程共享

<br>
>  堆是JVM用来存储对象实例以及数组值(数组在Java虚拟机中是一个真正的对象)的区域,可以认为Java中所有通过new创建的对象的内存都在堆中分配,堆中的对象所占的内存是需要等待GC进行回收的(JVM没有释放内存的指令,需要将释放内存的任务交给垃圾收集器处理)。堆是JVM中所有线程共享的。
>  - - -

<br>
<br>

* #### Java栈(Java stack) ——线程私有,生命周期与线程相同

<br>
>  每当启动一个线程时,Java虚拟机就会为他分配一个Java栈。Java栈由许多栈帧组成,一个栈帧包含一个对应的Java方法调用的状态。当线程调用一个Java方法时,虚拟机压入一个新的栈帧到Java栈中,当该方法返回时,这个栈帧就会从Java栈中弹出。
>
>  栈帧：由局部变量区,操作数栈和帧数据区组成。当虚拟机调用一个Java方法时,它从对应类的类型信息中得到此方法的局部变量区和操作数栈大小,并根据此来分配帧的内存,然后压入栈中。
>  * 局部变量区
>  >  局部变量区被组织为以字长为单位,从0开始计数的数组。字节码指令通过从0开始的索引使用其中的数据。类型为int, float, reference和returnAddress的值在数组中占据一项,而类型为byte, short和char的值在存入数组前都被转换为int值,也占据一项。但类型为long和double的值在数组中却占据连续的两项。如下图：
>  >  <br>
>  >  ![](/images/posts/jvm/image4.png)
>  >  <br>
>  * 操作数栈
>  >  与局部变量区一样,操作数栈被组织成一个以字长为单位的数组,其通过标准的栈操作访问。
>  >  <br>
>  * 帧数据区
>  >  Java栈帧需要帧数据区来支持常量池的解析——(每当虚拟机要执行一个需要操作常量池数据的指令时,就会通过帧数据区中指向常量池的指针来访问常量池),正常方法返回——(帧数据区还要帮助虚拟机处理Java方法的正常结束或异常中止。如果通过return正常结束，虚拟机必须恢复发起调用的方法的栈帧，包括设置程序计数器指向发起调用方法的下一个指令；如果方法有返回值，虚拟机需要将它压入到发起调用的方法的操作数栈)以及异常派发机制——(为了处理Java方法执行期间的异常退出情况，帧数据区还保存一个对此方法异常表的引用)。
>  	- - -

<br>
<br>

* #### PC寄存器(程序计数器 program counter)——线程私有,生命周期与线程相同

<br>
>  每一个线程都有它自己的PC寄存器,也是在该线程启动时创建的。PC寄存器的内容总是指向下一条即将被执行的指令的地址,这里的地址可以是一个本地地址,也可以是在方法区中相对于该方法的起始指令的偏移量。
>  <br>
>  如果线程执行Java方法,则PC寄存器保存的是下一条执行指令的地址。若线程执行的是本地方法,那么此时PC寄存器的值是"undefined"。
>  - - -

<br>
<br>

* #### 本地方法栈(native method stack)——线程私有,生命周期与线程相同

<br>
>  当线程调用Java方法时,虚拟机会创建一个新的栈帧并将其压入到对应线程的Java栈。当线程调用的是本地方法时,虚拟机会保持Java栈不变,不再向Java栈中压入新的栈帧,虚拟机只是简单的动态连接并调用指定的本地方法。
>  <br>
>  依赖于本地方法的实现,如某个JVM实现的本地方法接口使用C连接模型,则本地方法栈就是C栈,可以说某线程在调用本地方法时,就进入了一个不受JVM限制的领域,也就是JVM可以利用本地方法来动态扩展本身。
>  - - -

- - -
<br>
<br>
<br>


## JVM垃圾回收(Generational Collecting)

......




*参考来自* [深入理解Java虚拟机体系结构](http://www.cnblogs.com/lao-liang/p/5110710.html)       [什么是JVM?](http://blog.csdn.net/stanlee_0/article/details/51171382)
